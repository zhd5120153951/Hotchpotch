>魔法函数杂谈

## 1 什么是魔法函数?

- 魔法函数（Magic Methods），是Python的一种高级语法，允许在类中自定义函数(函数名格式一般为__xx__)，并绑定到类的特殊方法中。比如在类A中自定义__str__()函数，则在调用str(A())时，会自动调用__str__()函数，并返回相应的结果。经常使用的__init__函数(构造函数)和__del__函数(析构函数)，其实这也是魔法函数的一种。

- Python中以双下划线(__xx__)开始和结束的函数为魔法函数。(不可自己定义格式)
- 调用类实例化的对象的方法时自动调用魔法函数。
- 在自己定义的类中，可以实现之前的内置函数。

### 1.1 魔法函数的分类
    魔法函数:数学运算类和非数学运算类
## 2 魔法函数举例

### 2.1 __init__()
    隐式调用了我们手动创建的 __init__() 构造方法。不仅如此，在 __init__() 构造方法中，除了 self 参数外，还可以自定义一些参数，参数之间使用逗号“,”进行分割。

### 2.2 __str__()
    __ str__是被print函数调用的。打印一个实例化对象时，打印的其实时一个对象的地址。而通过__str__()函数就可以帮助我们打印对象中具体的属性值，或者你想得到的东西。在Python中调用print()打印实例化对象时会调用__str__()。如果__str__()中有返回值，就会打印其中的返回值。

### 2.3 __new__()
    __new__() 是一种负责创建类实例的静态方法，它无需使用 staticmethod 装饰器修饰，且该方法会优先 __init__() 初始化方法被调用。一般情况下，覆写 __new__() 的实现将会使用合适的参数调用其超类的 super().__new__()，并在返回之前修改实例。

### 2.4 __unicode__()
    __ unicode__()方法是在一个对象上调用unicode()时被调用的。因为Django的数据库后端会返回Unicode字符串给model属性，所以我们通常会给自己的model写一个__ unicode__()方法。如果定义了__ unicode__()方法但是没有定义__ str__()方法，Django会自动提供一个__ str__()方法调用 __ unicode__()方法，然后把结果转换为UTF-8编码的字符串对象，所以在一般情况下，只定义__ unicode__()方法，让 Django来处理字符串对象的转换

### 2.5 __call__()
    该方法的功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以“对象名()”的形式使用。

### 2.6 __len__()
    在Python中，如果你调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法。

### 2.7 __repr__()
    函数str() 用于将值转化为适于人阅读的形式，而repr() 转化为供解释器读取的形式，某对象没有适于人阅读的解释形式的话，str() 会返回与repr()，所以print展示的都是str的格式。

### 2.8 __setattr__()
    在类中对属性进行赋值操作时，python会自动调用__setattr__()函数，来实现对属性的赋值。但是重写__setattr__()函数时要注意防止无限递归的情况出现，一般解决办法有两种，一是用通过super()调用__setatrr__()函数，二是利用字典操作对相应键直接赋值。简单的说，__setattr__()在属性赋值时被调用，并且将值存储到实例字典中，这个字典应该是self的__dict__属性。即：在类实例的每个属性进行赋值时，都会首先调用__setattr__()方法，并在__setattr__()方法中将属性名和属性值添加到类实例的__dict__属性中。

#### 2.8.1 __setattr__()和__dict__()
        由于每次类实例进行属性赋值时都会调用__setattr__()，所以可以重载__setattr__()方法，来动态的观察每次实例属性赋值时__dict__()的变化。下面的Fun类重载了__setattr__()方法，并且将实例的属性和属性值作为__dict__的键-值对：
### 2.9 __getattr__()
    当我们访问一个不存在的属性的时候，会抛出异常，提示我们不存在这个属性。而这个异常就是__getattr__方法抛出的，其原因在于他是访问一个不存在的属性的最后落脚点，作为异常抛出的地方提示出错再适合不过了。

### 2.10 __getattribute__()
    __getattribute__是属性访问拦截器，就是当这个类的属性被访问时，会自动调用类的__getattribute__方法。即在上面代码中，当我调用实例对象aa的name属性时，不会直接打印，而是把name的值作为实参传进__getattribute__方法中（参数obj是我随便定义的，可任意起名），经过一系列操作后，再把name的值返回。Python中只要定义了继承object的类，就默认存在属性拦截器，只不过是拦截后没有进行任何操作，而是直接返回。所以我们可以自己改写__getattribute__方法来实现相关功能，比如查看权限、打印log日志等。如下代码，简单理解即可：

### 2.11 __delattr__()
    本函数的作用是删除属性，实现了该函数的类可以用del 命令来删除属性。

### 2.12 __setitem__()
    __setitem__(self,key,value)：该方法应该按一定的方式存储和key相关的value。在设置类实例属性时自动调用的。

### 2.13 __getitem__()
    Python的特殊方法__getitem_() 主要作用是可以让对象实现迭代功能。
    注意点:
    解释器需要迭代对象x时， 会自动调用iter(x)方法。内置的 iter(x) 方法有以下作用：检查对象是否实现了__iter__ 方法，如果实现了就调用它（也就是我们偶尔用到的特殊方法重载），获取一个迭代器。如果没有实现iter()方法， 但是实现了 __getitem__方法，Python会创建一个迭代器，尝试按顺序（从索引0开始，可以看到我们刚才是通过s[0]取值）获取元素。如果尝试失败，Python抛出TypeError异常，通常会提示TypeError: '***' object is not iterable。任何Python序列都可迭代的原因是，他们都实现了__getitem__方法。其实，标准的序列也都实现了__iter__方法。

### 2.14 __delitem__()
    这个方法在对对象的组成部分使用__del__语句的时候被调用，应删除与key相关联的值。同样，仅当对象可变的时候，才需要实现这个方法。

### 2.15 __iter__()
    迭代器就是重复地做一些事情，可以简单的理解为循环，在python中实现了__iter__方法的对象是可迭代的，实现了next()方法的对象是迭代器，这样说起来有点拗口，实际上要想让一个迭代器工作，至少要实现__iter__方法和next方法。很多时候使用迭代器完成的工作使用列表也可以完成，但是如果有很多值列表就会占用太多的内存，而且使用迭代器也让我们的程序更加通用、优雅、pythonic。如果一个类想被用于for ... in循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。
    注意点:
    容器（container）：

    容器是用来储存元素的一种数据结构，容器将所有数据保存在内存中，Python中典型的容器有：list，set，dict，str等等。---tuple不是容器,是一个整体---含有__next__()函数的对象都是一个迭代器

### 2.16 __del__()
    __del__() 方法，功能正好和 __init__() 相反，其用来销毁实例化对象。

    事实上在编写程序时，如果之前创建的类实例化对象后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间（整个过程称为垃圾回收（简称GC））。无论是手动销毁，还是 Python 自动帮我们销毁，都会调用 __del__() 方法。

### 2.17 __dir__()
    dir() 函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。

### 2.18 __dict__()
    在 Python 类的内部，无论是类属性还是实例属性，都是以字典的形式进行存储的，其中属性名作为键，而值作为该键对应的值。为了方便用户查看类中包含哪些属性，Python 类提供了__dict__ 属性。需要注意的一点是，该属性可以用类名或者类的实例对象来调用，用类名直接调用 __dict__，会输出该由类中所有类属性组成的字典；而使用类的实例对象调用 __dict__，会输出由类中所有实例属性组成的字典。

### 2.19 __exit__()和__enter__()
    __exit__和__enter__函数是与with语句的组合应用的，用于上下文管理。

    1.__enter(self)__：负责返回一个值，该返回值将赋值给as子句后面的var_name，通常返回对象自己，即“self”。函数优先于with后面的“代码块”(statements1,statements2,……)被执行。
    2.__exit__(self, exc_type, exc_val, exc_tb)：
